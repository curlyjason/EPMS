<?php


namespace App\Controller;


use App\Model\Table\CsvImportsTable;
use App\Model\Table\MaterialsTable;
use Cake\Cache\Cache;
use Cake\Filesystem\Folder;
use Cake\Http\Session;
use Cake\ORM\Entity;
use Cake\ORM\Table;
use Cake\Utility\Inflector;
use Laminas\Diactoros\UploadedFile;
use Stacks\Constants\LayerCon;
use Stacks\Model\Lib\Layer;

/**
 * Class CsvImportsController
 * @package App\Controller
 * @property CsvImportsTable CsvImports
 */
class CsvImportsController extends AppController
{
    /**
     * @var MaterialsTable
     */
    private $Materials;
    /**
     * @var \Cake\Datasource\RepositoryInterface|string|string[]|null
     */
    private $primaryKey;
    /**
     * @var Session|null
     */
    private $Session;
    private $uid;
    /**
     * @var Table $TargetTable
     * This is the table object determined by what is stored in the session
     */
    private $TargetTable;

    public function initialize(): void
    {
        parent::initialize(); // TODO: Change the autogenerated stub
        $this->Materials = $this->getTableLocator()->get('Materials');
        $this->Session = $this->getRequest()->getSession();
        if(is_null($this->Session->read('unique_id'))){
            $this->Session->write('unique_id', uniqid());
        }
        $this->uid = $this->Session->read('unique_id');
    }

    public function add()
    {
        $table = $this->CsvImports;
        $targets = $this->ormTables();

        if($this->getRequest()->is('post')) {
            /**
             * @var UploadedFile $file
             */
            $file = $this->getRequest()->getData('file');
            $this->Session->write('target_table', $this->getRequest()->getData('target'));
            $file->moveTo($this->getFilePath());
            return $this->redirect(['action' => 'map']);
        }

        $this->set(compact('table', 'targets'));
    }

    public function map()
    {
        $this->setTargetTableFromSession(); //creates the schema
        $target_columns = $this->TargetTable->getSchema()->columns();
        $target_columns = array_combine($target_columns, $target_columns);
        $this->CsvImports->import($this->getFileName());
        $source_columns = $this->CsvImports->getSchema()->columns();

        if($this->getRequest()->is('post') && $this->validMap()){
            $this->Session->write('map', $this->getRequest()->getData());
            return $this->redirect(['action' => 'processAddMap']);
        }

        $target_table = $this->TargetTable->getAlias();
        $this->set(compact('target_columns', 'source_columns', 'target_table'));
    }

    public function processAddMap()
    {
        $this->setTargetTableFromSession();
        list($reduced_map, $manual_map) = $this->fetchColumnHeaderMaps();
        $import = $this->CsvImports->import($this->getFileName());

        $existing_records = $this->getExistingRecordsForImportData($this->primaryKey);
        $patch_data = $this->convertImportToPatchData($import, $reduced_map);
        $records = $this->TargetTable->patchEntities($existing_records, $patch_data);

        if ($this->getRequest()->is('post')){
            $result = $this->TargetTable->saveMany($records);
            if($result){
                $this->Flash->success("All records updated!");
                $this->redirect('pages/home');
            }
            else {
                $this->Flash->error("Problem saving records.");
                foreach ($records as $entity) {
                    if($entity->hasErrors()){
                        var_export($entity->getErrors());
                    }
                }
            }
        }

        $primary_key = $this->primaryKey;
        $this->set(compact( 'reduced_map', 'primary_key', 'manual_map', 'records'));
    }

    private function validMap(): bool
    {
        $map = $this->getRequest()->getData();
        $assigned_targets = [];
        $return = true;
        $result = collection($map)
            ->reduce(function($accum, $target, $source) use (&$assigned_targets){
                if (!empty($target)) {
                    if (!array_key_exists($target, $assigned_targets)) {
                        $assigned_targets[$target] = $target;
                    }
                    else {
                        $this->Flash->error("You cannot assign $target to two sources");
                        $accum['duplicates'] = true;
                    }
                }
                if ($target == 'MaterialCode') {
                    $this->Session->write('key', $source);
                    $accum['MaterialCode'] = true;
                }
                return $accum;
            }, ['MaterialCode' => false, 'duplicates' => false]);

        if(!$result['MaterialCode']){
            $this->Flash->error("You must target the MaterialCode");
            $return = false;
        }
        if($result['duplicates']){
            $return = false;
        }
        return $return;
    }

    /**
     * Get an array of standard ORM table names (in alias form)
     *
     * @return array|null
     */
    private function ormTables(): array
    {
        $tableDir = new Folder(APP.'Model'.DS.'Table');
        $allFiles = ($tableDir->find('.*Table.php'));
        $files = collection($allFiles)
            ->reduce(function($accum, $file) {
                if (!preg_match('/Stack/', $file)) {
                    $accum[] = str_replace('Table.php', '', $file);
                }
                return $accum;
            }, []);
        return array_combine($files, $files);
    }

    /**
     * @param Entity $target_record
     */
    private function getPrimaryKey($target_record)
    {
        $alias = $target_record->getSource();
        $table = $this->getTableLocator()->get($alias);
        return $table->getPrimaryKey();

    }

    /**
     * @return string
     */
    private function getFilePath(): string
    {
        return WWW_ROOT . 'files/' . $this->getFileName();
    }

    /**
     * @return string
     */
    private function getFileName(): string
    {
        return "$this->uid-workingFile.csv";
    }

    private function convertImportToPatchData(array $import, $reduced_map)
    {
        return collection($import)
            ->reduce(function($accum, $record, $key) use ($reduced_map){
                $accum[$key] = collection($reduced_map)
                    ->reduce(function($element, $target_key, $source_key) use ($record){
                        $element[$target_key] = $record->$source_key;
                        return $element;
                    }, []);
                $accum[$key][$this->primaryKey] = $record->id;
                $target_table = $this->Session->read('target_table');
                $accum[$key] = $this->TargetTable->fixPatchData($accum[$key]);
                return $accum;
            }, []);
    }

    /**
     * @param array $import
     * @param $key
     * @param $target_table
     * @param $primary_key
     * @return array
     */
    private function getExistingRecordsForImportData($primary_key): array
    {
        $import = $this->CsvImports->import($this->getFileName());
        $key = $this->Session->read('key');
        $find_array = collection($import)
            ->reduce(function ($accum, $record) use ($key) {
                $accum[] = $record->$key;
                return $accum;
            }, []);
        $existing_records = $this->TargetTable->find('all')
            ->where(["$primary_key IN" => $find_array])
            ->toArray();
        return $existing_records;
    }

    private function setTargetTableFromSession(): void
    {
        $target_table = $this->Session->read('target_table');
        $this->TargetTable = $this->getTableLocator()->get($target_table);
        $this->primaryKey = $this->TargetTable->getPrimaryKey();
    }

    /**
     * @return array
     */
    private function fetchColumnHeaderMaps(): array
    {
        $map = $this->Session->read('map');
        $key = $this->Session->read('key');
        $reduced_map = $this->reduceMap($map, $key);
        $manual_map = $this->filterManualEntriesInReducedMap($reduced_map);
        return array($reduced_map, $manual_map);
    }

    private function reduceMap($map, $key): array
    {
        return collection($map)
            ->reduce(function($accum, $target, $source) use ($key){
                if(!empty($target) && $source != $key){
                    $accum[$source] = $target;
                }
                return $accum;
            }, []);
    }

    private function filterManualEntriesInReducedMap($reduced_map): array
    {
        return collection($reduced_map)
            ->filter(function($target_column, $source_column){
                return strtolower(Inflector::camelize($target_column)) != strtolower(Inflector::camelize($source_column));
            })->toArray();
    }



}
